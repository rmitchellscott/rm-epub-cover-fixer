<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB Cover Fixer for reMarkable</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        border: "hsl(var(--border))",
                        input: "hsl(var(--input))",
                        ring: "hsl(var(--ring))",
                        background: "hsl(var(--background))",
                        foreground: "hsl(var(--foreground))",
                        primary: {
                            DEFAULT: "hsl(var(--primary))",
                            foreground: "hsl(var(--primary-foreground))",
                        },
                        secondary: {
                            DEFAULT: "hsl(var(--secondary))",
                            foreground: "hsl(var(--secondary-foreground))",
                        },
                        destructive: {
                            DEFAULT: "hsl(var(--destructive))",
                            foreground: "hsl(var(--destructive-foreground))",
                        },
                        muted: {
                            DEFAULT: "hsl(var(--muted))",
                            foreground: "hsl(var(--muted-foreground))",
                        },
                        accent: {
                            DEFAULT: "hsl(var(--accent))",
                            foreground: "hsl(var(--accent-foreground))",
                        },
                        card: {
                            DEFAULT: "hsl(var(--card))",
                            foreground: "hsl(var(--card-foreground))",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                }
            },
        }
    </script>
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 0 0% 3.9%;
            --card: 0 0% 100%;
            --card-foreground: 0 0% 3.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 0 0% 3.9%;
            --primary: 0 0% 9%;
            --primary-foreground: 0 0% 98%;
            --secondary: 0 0% 96.1%;
            --secondary-foreground: 0 0% 9%;
            --muted: 0 0% 96.1%;
            --muted-foreground: 0 0% 45.1%;
            --accent: 0 0% 96.1%;
            --accent-foreground: 0 0% 9%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 0 0% 98%;
            --border: 0 0% 89.8%;
            --input: 0 0% 89.8%;
            --ring: 0 0% 3.9%;
            --radius: 0.5rem;
        }
        
        .dark {
            --background: 0 0% 3.9%;
            --foreground: 0 0% 98%;
            --card: 0 0% 3.9%;
            --card-foreground: 0 0% 98%;
            --popover: 0 0% 3.9%;
            --popover-foreground: 0 0% 98%;
            --primary: 0 0% 98%;
            --primary-foreground: 0 0% 9%;
            --secondary: 0 0% 14.9%;
            --secondary-foreground: 0 0% 98%;
            --muted: 0 0% 14.9%;
            --muted-foreground: 0 0% 63.9%;
            --accent: 0 0% 14.9%;
            --accent-foreground: 0 0% 98%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 0 0% 98%;
            --border: 0 0% 14.9%;
            --input: 0 0% 14.9%;
            --ring: 0 0% 83.1%;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Tooltip animations */
        .tooltip {
            transform-origin: bottom center;
        }
        .tooltip.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        input[type="file"] {
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body class="min-h-screen bg-background font-sans antialiased">
    <div class="container mx-auto max-w-4xl p-6 space-y-8">
        <!-- Main Card Container -->
        <div class="text-card-foreground p-6 space-y-8">
        <div class="flex items-start justify-between">
            <div class="space-y-2">
                <h1 class="text-3xl font-bold tracking-tight text-foreground">Fix eBook Covers</h1>
                <p class="text-muted-foreground">Automatically detect and fix common EPUB cover display issues on reMarkable devices. Runs entirely in the browser, no data is sent to a server.</p>
            </div>
            <div class="relative" id="themeTooltipContainer">
                <button
                    id="themeToggle"
                    class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground h-10 w-10"
                    type="button"
                    aria-label="Toggle theme"
                    aria-describedby="themeTooltip"
                >
                    <span id="themeIcon" class="w-5 h-5"></span>
                </button>
                <div 
                    id="themeTooltip" 
                    role="tooltip"
                    class="tooltip absolute bottom-full right-0 mb-2 px-3 py-1.5 text-sm text-popover-foreground bg-popover rounded-md shadow-md z-50 opacity-0 scale-95 pointer-events-none transition-all duration-150 ease-out whitespace-nowrap"
                >
                    <span id="tooltipText">Switch to dark</span>
                    <div class="absolute top-full right-4 w-0 h-0 border-l-[6px] border-r-[6px] border-t-[6px] border-l-transparent border-r-transparent border-t-popover"></div>
                </div>
            </div>
        </div>
        
        <!-- Upload Area -->
        <div class="rounded-lg border-2 border-dashed border-border bg-card hover:bg-accent/50 transition-colors cursor-pointer" id="uploadArea">
            <div class="p-12 text-center space-y-4">
                <div class="mx-auto w-12 h-12 text-muted-foreground">
                    <svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </div>
                <div class="space-y-2">
                    <p class="text-lg font-medium">Drop EPUB files here or click to browse</p>
                    <p class="text-sm text-muted-foreground">Supports multiple .epub files • Drag & drop or click to select</p>
                </div>
            </div>
        </div>
        
        <input type="file" id="fileInput" accept=".epub" multiple>
        
        <!-- Global Status Messages -->
        <div id="globalStatus" class="space-y-4" style="display: none;"></div>
        
        <!-- File List -->
        <div id="fileListContainer" style="display: none;">
            <div class="p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold">Selected Files</h2>
                        <div class="flex items-center gap-2" id="batchButtonsContainer">
                            <button id="analyzeAllBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-9 px-3">
                                Analyze All
                            </button>
                            <button id="fixAllBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-9 px-3" disabled>
                                Fix All
                            </button>
                            <button id="downloadAllBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-9 px-3" disabled>
                                Download All
                            </button>
                            <button id="clearAllBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-9 px-3">
                                Clear All
                            </button>
                        </div>
                    </div>
                    <div id="fileList" class="space-y-3"></div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
    // Theme Management
    class ThemeManager {
        constructor() {
            this.LOCALSTORAGE_KEY = "color-scheme";
            this.mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
            this.icons = {
                auto: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.997c-5.523 0-10-4.477-10-10s4.477-10 10-10s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m0-2v-12a6 6 0 0 1 0 12"/></svg>',
                light: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="transform: rotate(-90deg); transform-origin: 50% 50%;"><path d="M12 21.997c-5.523 0-10-4.477-10-10s4.477-10 10-10s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m0-2v-12a6 6 0 0 1 0 12"/></svg>',
                dark: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.997c-5.523 0-10-4.477-10-10s4.477-10 10-10s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m-5-4.681a8.965 8.965 0 0 0 5.707-2.612a8.965 8.965 0 0 0 2.612-5.707A6 6 0 1 1 7 15.316"/></svg>'
            };
            this.init();
        }

        storedToBool(s) {
            if (s === "dark") return true;
            else if (s === "light") return false;
            else return null; // "auto" or null
        }

        ensureScheme(desiredScheme, isInitialization = false) {
            let schemeName;
            if (desiredScheme === null) {
                desiredScheme = this.mediaQuery.matches;
                schemeName = "auto";
                if (isInitialization || localStorage.getItem(this.LOCALSTORAGE_KEY) !== "auto") {
                    localStorage.setItem(this.LOCALSTORAGE_KEY, "auto");
                }
            } else {
                schemeName = desiredScheme ? "dark" : "light";
                localStorage.setItem(this.LOCALSTORAGE_KEY, schemeName);
            }

            if (desiredScheme) {
                document.documentElement.classList.add("dark");
            } else {
                document.documentElement.classList.remove("dark");
            }
            
            this.updateIcon(schemeName);
            this.updateTooltip(schemeName);
        }

        updateIcon(schemeName) {
            const element = document.getElementById('themeIcon');
            if (element) {
                element.innerHTML = this.icons[schemeName] || this.icons.auto;
            }
        }

        updateTooltip(currentScheme) {
            const tooltipText = document.getElementById('tooltipText');
            if (tooltipText) {
                const nextScheme = this.getNextScheme(currentScheme);
                const labels = { auto: 'auto', dark: 'dark', light: 'light' };
                tooltipText.textContent = `Switch to ${labels[nextScheme]}`;
            }
        }

        getNextScheme(current) {
            if (current === 'auto') return 'dark';
            else if (current === 'dark') return 'light';
            else return 'auto';
        }

        init() {
            let storedScheme = this.storedToBool(localStorage.getItem(this.LOCALSTORAGE_KEY));
            if (storedScheme === undefined) storedScheme = null;

            this.ensureScheme(storedScheme, true);
            this.mediaQuery.addEventListener("change", (e) => {
                if (localStorage.getItem(this.LOCALSTORAGE_KEY) === "auto") {
                    this.ensureScheme(null, true);
                }
            });

            this.setupEventListeners();
        }

        setupEventListeners() {
            const toggle = document.getElementById('themeToggle');
            const tooltip = document.getElementById('themeTooltip');
            
            if (toggle) {
                toggle.addEventListener('click', () => this.toggleTheme());
                toggle.addEventListener('mouseenter', () => this.showTooltip());
                toggle.addEventListener('mouseleave', () => this.hideTooltip());
            }
        }

        toggleTheme() {
            let currentScheme = localStorage.getItem(this.LOCALSTORAGE_KEY);
            if (currentScheme === "auto") {
                this.ensureScheme(true); // Switch to dark
            } else if (currentScheme === "dark") {
                this.ensureScheme(false); // Switch to light
            } else {
                this.ensureScheme(null); // Switch to auto
            }
        }

        showTooltip() {
            const tooltip = document.getElementById('themeTooltip');
            if (tooltip) {
                tooltip.classList.add('show');
            }
        }

        hideTooltip() {
            const tooltip = document.getElementById('themeTooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }
        }
    }

    class EPUBCoverFixer {
        constructor() {
            this.files = new Map(); // Map of filename -> file data
            this.setupEventListeners();
        }

        setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const analyzeAllBtn = document.getElementById('analyzeAllBtn');
            const fixAllBtn = document.getElementById('fixAllBtn');
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');

            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('border-primary', 'bg-primary/5');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('border-primary', 'bg-primary/5');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('border-primary', 'bg-primary/5');
                if (e.dataTransfer.files.length > 0) {
                    this.handleFiles(Array.from(e.dataTransfer.files));
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    this.handleFiles(Array.from(e.target.files));
                }
            });
            
            analyzeAllBtn.addEventListener('click', () => this.analyzeAllFiles());
            fixAllBtn.addEventListener('click', () => this.fixAllFiles());
            downloadAllBtn.addEventListener('click', () => this.downloadAllFiles());
            clearAllBtn.addEventListener('click', () => this.clearAllFiles());
        }

        async handleFiles(fileList) {
            const epubFiles = fileList.filter(file => file.name.toLowerCase().endsWith('.epub'));
            
            if (epubFiles.length === 0) {
                this.showGlobalError('Please select valid EPUB files');
                return;
            }
            
            if (epubFiles.length !== fileList.length) {
                this.showGlobalWarning(`${fileList.length - epubFiles.length} non-EPUB file(s) ignored`);
            }
            
            for (const file of epubFiles) {
                await this.addFile(file);
            }
            
            this.updateUI();
        }
        
        async addFile(file) {
            const fileData = {
                file: file,
                filename: file.name,
                status: 'pending', // pending, analyzing, analyzed, fixing, fixed, error
                zip: null,
                issues: [],
                fixes: [],
                fixedZip: null,
                opfPath: '',
                opfDir: '',
                coverImagePath: '',
                error: null
            };
            
            this.files.set(file.name, fileData);
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                fileData.zip = await JSZip.loadAsync(arrayBuffer);
            } catch (error) {
                fileData.status = 'error';
                fileData.error = 'Failed to load EPUB: ' + error.message;
            }
        }

        async analyzeFile(filename) {
            const fileData = this.files.get(filename);
            if (!fileData || !fileData.zip) return;
            
            fileData.status = 'analyzing';
            this.updateFileItem(filename);
            
            try {
                await this.analyzeEPUB(fileData);
                fileData.status = 'analyzed';
            } catch (error) {
                fileData.status = 'error';
                fileData.error = 'Analysis failed: ' + error.message;
            }
            
            this.updateFileItem(filename);
            this.updateBatchButtons();
        }
        
        async analyzeEPUB(fileData) {
            fileData.issues = [];
            
            // Find container.xml
            const containerXml = await this.getFileContent(fileData, 'META-INF/container.xml');
            if (!containerXml) {
                throw new Error('Invalid EPUB: No container.xml found');
            }
            
            // Parse container to find OPF
            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(containerXml, 'text/xml');
            const rootfile = containerDoc.querySelector('rootfile');
            if (!rootfile) {
                throw new Error('Invalid EPUB: No rootfile in container.xml');
            }
            
            fileData.opfPath = rootfile.getAttribute('full-path');
            fileData.opfDir = fileData.opfPath.substring(0, fileData.opfPath.lastIndexOf('/'));
            
            // Check if using OEBPS instead of EPUB
            if (fileData.opfDir.includes('OEBPS')) {
                fileData.issues.push({
                    type: 'directory',
                    description: 'Uses OEBPS directory instead of EPUB',
                    severity: 'medium'
                });
            }
            
            // Analyze OPF
            const opfContent = await this.getFileContent(fileData, fileData.opfPath);
            if (!opfContent) {
                throw new Error('Invalid EPUB: Cannot read OPF file');
            }
            
            const opfDoc = parser.parseFromString(opfContent, 'text/xml');
            
            // Check for cover metadata (EPUB 2.0 and 3.0 formats)
            const coverMeta = opfDoc.querySelector('meta[name="cover"]');
            const coverItem = opfDoc.querySelector('item[properties*="cover-image"]');
            
            if (!coverMeta && !coverItem) {
                fileData.issues.push({
                    type: 'metadata',
                    description: 'No cover image properly identified in metadata',
                    severity: 'high'
                });
            } else if (coverMeta && !coverItem) {
                // EPUB 2.0 style - check if cover image item lacks properties
                const coverId = coverMeta.getAttribute('content');
                const imageItem = opfDoc.querySelector(`item[id="${coverId}"]`);
                if (imageItem && !imageItem.getAttribute('properties')) {
                    fileData.issues.push({
                        type: 'metadata',
                        description: 'Cover image missing properties="cover-image" attribute',
                        severity: 'medium'
                    });
                }
            }
            
            // Check spine for cover - multiple detection methods
            const spine = opfDoc.querySelector('spine');
            const spineItems = Array.from(spine.querySelectorAll('itemref'));
            
            // Method 1: Find items with cover-related terms in id or href (case-insensitive)
            // Support multiple languages: cover, cubierta (Spanish), couverture (French), copertina (Italian), etc.
            const coverTerms = ['cover', 'cubierta', 'couverture', 'copertina', 'capa', 'omslag'];
            let coverInSpine = spineItems.find(ref => {
                const id = ref.getAttribute('idref');
                const item = opfDoc.querySelector(`item[id="${id}"]`);
                if (!item) return false;
                
                const href = item.getAttribute('href') || '';
                const itemId = item.getAttribute('id') || '';
                
                return coverTerms.some(term => 
                    href.toLowerCase().includes(term) || 
                    itemId.toLowerCase().includes(term)
                );
            });
            
            // Method 2: Check if first item in spine might be cover (common pattern)
            if (!coverInSpine && spineItems.length > 0) {
                const firstRef = spineItems[0];
                const firstId = firstRef.getAttribute('idref');
                const firstItem = opfDoc.querySelector(`item[id="${firstId}"]`);
                
                if (firstItem) {
                    const href = firstItem.getAttribute('href') || '';
                    // Check if it's likely a cover based on common patterns
                    if (href.match(/01_|^cover|frontcover/i) || firstId.match(/cover|^x01/i)) {
                        coverInSpine = firstRef;
                        console.log(`Detected likely cover as first spine item: ${firstId}`);
                    }
                }
            }
            
            // Method 3: Check if cover metadata points to a spine item or first item is likely cover
            if (!coverInSpine && coverMeta) {
                const coverId = coverMeta.getAttribute('content');
                // Find if there's a spine item that references a cover HTML
                coverInSpine = spineItems.find(ref => {
                    const id = ref.getAttribute('idref');
                    return id && coverTerms.some(term => id.toLowerCase().includes(term));
                });
            }
            
            // Method 4: Check if first spine item contains cover image or SVG (common in EPUB 2.0)
            if (!coverInSpine && spineItems.length > 0 && coverMeta) {
                const firstRef = spineItems[0];
                const firstId = firstRef.getAttribute('idref');
                const firstItem = opfDoc.querySelector(`item[id="${firstId}"]`);
                if (firstItem) {
                    // Check if this HTML file might be a cover by checking if it references cover image
                    const coverId = coverMeta.getAttribute('content');
                    if (coverId) {
                        coverInSpine = firstRef;
                        console.log(`Detected likely cover as first spine item that might reference cover image: ${firstId}`);
                    }
                }
            }
            
            // Check if cover in spine has proper linear="no" attribute
            if (coverInSpine) {
                const linearAttr = coverInSpine.getAttribute('linear');
                const refId = coverInSpine.getAttribute('idref');
                if (linearAttr !== 'no') {
                    fileData.issues.push({
                        type: 'spine',
                        description: `Cover in spine (id: ${refId}) missing linear="no" attribute`,
                        severity: 'high'
                    });
                }
            } else {
                console.log('No cover detected in spine - this might be okay if cover is external');
            }
            
            // Check for cover image location
            let coverImageItem = coverItem;
            if (!coverImageItem && coverMeta) {
                const coverId = coverMeta.getAttribute('content');
                coverImageItem = opfDoc.querySelector(`item[id="${coverId}"]`);
            }
            
            if (coverImageItem) {
                fileData.coverImagePath = coverImageItem.getAttribute('href');
                if (!fileData.coverImagePath.includes('covers/')) {
                    fileData.issues.push({
                        type: 'structure',
                        description: 'Cover image not in covers/ subdirectory',
                        severity: 'low'
                    });
                }
                
                // Check file extension
                if (fileData.coverImagePath.endsWith('.jpeg')) {
                    fileData.issues.push({
                        type: 'format',
                        description: 'Cover uses .jpeg extension instead of .jpg',
                        severity: 'low'
                    });
                }
            }
            
            // Check for cover HTML structure
            const coverHtmlItem = opfDoc.querySelector('item[id*="cover"]:not([media-type*="image"])');
            if (coverHtmlItem) {
                const coverHtmlPath = this.resolvePathFromOPF(fileData, coverHtmlItem.getAttribute('href'));
                const coverHtml = await this.getFileContent(fileData, coverHtmlPath);
                if (coverHtml) {
                    const coverDoc = parser.parseFromString(coverHtml, 'text/html');
                    const hasFigure = coverDoc.querySelector('figure');
                    const hasComplexDiv = coverDoc.querySelector('div[class*="height"]');
                    
                    if (!hasFigure && hasComplexDiv) {
                        fileData.issues.push({
                            type: 'html',
                            description: 'Cover HTML uses complex div structure instead of simple figure/img',
                            severity: 'medium'
                        });
                    }
                }
            }
        }



        async createSeparateCover(fileData) {
            // Get EPUB version to determine approach
            const opfContent = await this.getFileContent(fileData, fileData.opfPath);
            const parser = new DOMParser();
            const opfDoc = parser.parseFromString(opfContent, 'text/xml');
            const epubVersion = opfDoc.documentElement.getAttribute('version');
            
            // Create appropriate cover HTML based on EPUB version
            let coverHTML;
            let fileName;
            
            if (epubVersion === '2.0') {
                // EPUB 2.0 - create titlepage.xhtml at root (like working Atmosphere book)
                // Use SVG structure like the working book
                coverHTML = `<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="calibre:cover" content="true"/>
        <title>Cover</title>
        <style type="text/css" title="override_css">
            @page {padding: 0pt; margin:0pt}
            body { text-align: center; padding:0pt; margin: 0pt; }
        </style>
    </head>
    <body>
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 600 900" preserveAspectRatio="none">
                <image width="600" height="900" xlink:href="cover.jpeg"/>
            </svg>
        </div>
    </body>
</html>`;
                fileName = 'titlepage.xhtml';
            } else {
                // EPUB 3.0+ - use figure/img structure
                coverHTML = `<?xml version="1.0" encoding="utf-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
    <head>
        <title>Cover</title>
        <style type="text/css">
            img{
                max-width:100%;
            }
        </style>
    </head>
    <body>
        <figure id="cover-image">
            <img role="doc-cover" src="covers/cover.jpg" alt="Book Cover" />
        </figure>
    </body>
</html>`;
                fileName = 'cover.xhtml';
            }
            
            const epubDir = fileData.opfDir.includes('OEBPS') ? 'EPUB' : fileData.opfDir;
            fileData.fixedZip.file(`${epubDir}/${fileName}`, coverHTML);
            fileData.fixes.push(`Created ${fileName} at ${epubDir} root for EPUB ${epubVersion}`);
        }
        
        async fixOPF(fileData) {
            const opfContent = await this.getFileContent(fileData, fileData.opfPath);
            const parser = new DOMParser();
            const opfDoc = parser.parseFromString(opfContent, 'text/xml');
            const epubVersion = opfDoc.documentElement.getAttribute('version');
            
            // Update manifest to include new cover structure
            const manifest = opfDoc.querySelector('manifest');
            
            // Add appropriate cover HTML file based on EPUB version
            const coverItemId = epubVersion === '2.0' ? 'titlepage' : 'cover';
            const coverFileName = epubVersion === '2.0' ? 'titlepage.xhtml' : 'cover.xhtml';
            
            if (!opfDoc.querySelector(`item[id="${coverItemId}"]`)) {
                const coverItem = opfDoc.createElement('item');
                coverItem.setAttribute('id', coverItemId);
                coverItem.setAttribute('href', coverFileName);
                coverItem.setAttribute('media-type', 'application/xhtml+xml');
                manifest.insertBefore(coverItem, manifest.firstChild);
                fileData.fixes.push(`Added ${coverFileName} to manifest`);
            }
            
            // Update cover image reference
            let coverImageItem = opfDoc.querySelector('item[properties*="cover-image"]');
            if (!coverImageItem) {
                const coverMeta = opfDoc.querySelector('meta[name="cover"]');
                if (coverMeta) {
                    const coverId = coverMeta.getAttribute('content');
                    coverImageItem = opfDoc.querySelector(`item[id="${coverId}"]`);
                }
            }
            
            if (coverImageItem) {
                // Update existing cover image item based on EPUB version
                if (epubVersion === '2.0') {
                    coverImageItem.setAttribute('href', 'cover.jpeg');
                    fileData.fixes.push('Updated cover image path for EPUB 2.0');
                } else {
                    coverImageItem.setAttribute('href', 'covers/cover.jpg');
                    coverImageItem.setAttribute('properties', 'cover-image');
                    fileData.fixes.push('Updated cover image path to covers/cover.jpg');
                }
            } else {
                // Check if we need to create/update cover image item
                const coverMeta = opfDoc.querySelector('meta[name="cover"]');
                if (coverMeta) {
                    const coverId = coverMeta.getAttribute('content');
                    coverImageItem = opfDoc.querySelector(`item[id="${coverId}"]`);
                    
                    if (coverImageItem) {
                        // Update existing item
                        if (epubVersion === '2.0') {
                            // For EPUB 2.0, place cover image at root level and use .jpeg extension
                            coverImageItem.setAttribute('href', 'cover.jpeg');
                            fileData.fixes.push('Updated cover image path for EPUB 2.0');
                        } else {
                            coverImageItem.setAttribute('href', 'covers/cover.jpg');
                            coverImageItem.setAttribute('properties', 'cover-image');
                            fileData.fixes.push('Updated cover image path to covers/cover.jpg');
                        }
                    }
                } else {
                    // Create new cover-image item
                    const newCoverItem = opfDoc.createElement('item');
                    newCoverItem.setAttribute('id', 'cover');
                    if (epubVersion === '2.0') {
                        newCoverItem.setAttribute('href', 'cover.jpeg');
                    } else {
                        newCoverItem.setAttribute('href', 'covers/cover.jpg');
                        newCoverItem.setAttribute('properties', 'cover-image');
                    }
                    newCoverItem.setAttribute('media-type', 'image/jpeg');
                    manifest.appendChild(newCoverItem);
                    fileData.fixes.push('Added cover image to manifest');
                }
            }
            
            // For EPUB 2.0, keep original cover metadata pointing to image for general e-reader compatibility
            // The titlepage.xhtml will be added separately for reMarkable compatibility
            // Don't change the cover metadata - other e-readers need it to point to the image
            
            // Fix spine
            const spine = opfDoc.querySelector('spine');
            const spineItems = Array.from(spine.querySelectorAll('itemref'));
            
            // Remove endpapers from spine
            spineItems.forEach(ref => {
                const id = ref.getAttribute('idref');
                if (id && id.toLowerCase().includes('endpaper')) {
                    ref.remove();
                    fileData.fixes.push(`Removed ${id} from spine`);
                }
            });
            
            // Handle spine differently for EPUB 2.0 vs 3.0
            if (epubVersion === '2.0') {
                // For EPUB 2.0, ensure titlepage is first in spine (like working Atmosphere book)
                // This is needed for reMarkable to display the cover properly
                let titlePageRef = spine.querySelector('itemref[idref="titlepage"]');
                if (!titlePageRef) {
                    titlePageRef = opfDoc.createElement('itemref');
                    titlePageRef.setAttribute('idref', 'titlepage');
                    spine.insertBefore(titlePageRef, spine.firstChild);
                    fileData.fixes.push('Added titlepage to spine as first item (EPUB 2.0)');
                } else if (spine.firstChild !== titlePageRef) {
                    spine.insertBefore(titlePageRef, spine.firstChild);
                    fileData.fixes.push('Moved titlepage to first position in spine (EPUB 2.0)');
                }
            } else {
                // For EPUB 3.0+, ensure cover is first with linear="no"
                let coverRef = spine.querySelector('itemref[idref="cover"]');
                if (!coverRef) {
                    coverRef = opfDoc.createElement('itemref');
                    coverRef.setAttribute('idref', 'cover');
                    coverRef.setAttribute('linear', 'no');
                    spine.insertBefore(coverRef, spine.firstChild);
                    fileData.fixes.push('Added cover to spine with linear="no"');
                } else {
                    coverRef.setAttribute('linear', 'no');
                    if (spine.firstChild !== coverRef) {
                        spine.insertBefore(coverRef, spine.firstChild);
                    }
                    fileData.fixes.push('Ensured cover is first in spine with linear="no"');
                }
            }
            
            // Handle other cover-like items in spine based on EPUB version
            const remainingSpineItems = Array.from(spine.querySelectorAll('itemref'));
            const coverTerms = ['cover', 'cubierta', 'couverture', 'copertina', 'capa', 'omslag'];
            
            remainingSpineItems.forEach(ref => {
                const id = ref.getAttribute('idref');
                if (id && id !== 'cover' && id !== 'titlepage') {
                    const item = opfDoc.querySelector(`item[id="${id}"]`);
                    if (item) {
                        const href = item.getAttribute('href') || '';
                        const itemId = item.getAttribute('id') || '';
                        
                        if (coverTerms.some(term => 
                            href.toLowerCase().includes(term) || 
                            itemId.toLowerCase().includes(term)
                        )) {
                            if (epubVersion === '2.0') {
                                // For EPUB 2.0, remove other cover items from spine entirely
                                // Only titlepage should be in spine for cover functionality
                                ref.remove();
                                fileData.fixes.push(`Removed ${id} from spine (EPUB 2.0 - only titlepage should be in spine)`);
                            } else {
                                // For EPUB 3.0+, apply linear="no"
                                if (ref.getAttribute('linear') !== 'no') {
                                    ref.setAttribute('linear', 'no');
                                    fileData.fixes.push(`Added linear="no" to ${id}`);
                                }
                            }
                        }
                    }
                }
            });
            
            // For EPUB 2.0, don't add linear="no" - it's not needed and can cause issues
            if (epubVersion === '2.0') {
                console.log('EPUB 2.0 detected - skipping linear="no" modifications');
                // Instead, ensure proper cover structure exists at root level
            } else {
                // EPUB 3.0+ - apply linear="no" as before for covers
                const firstSpineItem = spine.querySelector('itemref');
                if (firstSpineItem && firstSpineItem.getAttribute('linear') !== 'no') {
                    const coverMeta = opfDoc.querySelector('meta[name="cover"]');
                    if (coverMeta) {
                        firstSpineItem.setAttribute('linear', 'no');
                        const firstId = firstSpineItem.getAttribute('idref');
                        fileData.fixes.push(`Added linear="no" to first spine item ${firstId} (likely cover)`);
                    }
                }
            }
            
            // Fix guide references for EPUB 2.0
            if (epubVersion === '2.0') {
                let guide = opfDoc.querySelector('guide');
                if (!guide) {
                    guide = opfDoc.createElement('guide');
                    opfDoc.documentElement.appendChild(guide);
                    fileData.fixes.push('Added guide section');
                }
                
                // Update or add cover reference to point to root-level titlepage
                let coverRef = guide.querySelector('reference[type="cover"]');
                if (!coverRef) {
                    coverRef = opfDoc.createElement('reference');
                    coverRef.setAttribute('type', 'cover');
                    guide.appendChild(coverRef);
                }
                
                coverRef.setAttribute('href', 'titlepage.xhtml');
                coverRef.setAttribute('title', 'Cover');
                fileData.fixes.push('Updated guide reference to point to root-level titlepage');
            }
            
            // Serialize and save
            const serializer = new XMLSerializer();
            const fixedOPF = serializer.serializeToString(opfDoc);
            
            const newOPFPath = fileData.opfPath.replace('OEBPS/', 'EPUB/');
            fileData.fixedZip.file(newOPFPath, fixedOPF);
        }

        async fixContainer(fileData) {
            const containerXml = await this.getFileContent(fileData, 'META-INF/container.xml');
            let fixedContainer = containerXml;
            
            // Update to EPUB directory if needed
            if (containerXml.includes('OEBPS/')) {
                fixedContainer = containerXml.replace(/OEBPS\//g, 'EPUB/');
                fileData.fixes.push('Updated container.xml to reference EPUB directory');
            }
            
            // Update OPF filename if needed
            const parser = new DOMParser();
            const containerDoc = parser.parseFromString(fixedContainer, 'text/xml');
            const rootfile = containerDoc.querySelector('rootfile');
            if (rootfile) {
                const fullPath = rootfile.getAttribute('full-path');
                if (fullPath && !fullPath.includes('package.opf')) {
                    // Keep original OPF name but ensure it's in EPUB directory
                    const opfName = fullPath.split('/').pop();
                    rootfile.setAttribute('full-path', `EPUB/${opfName}`);
                }
                
                const serializer = new XMLSerializer();
                fixedContainer = serializer.serializeToString(containerDoc);
            }
            
            fileData.fixedZip.file('META-INF/container.xml', fixedContainer);
        }



        // Helper methods
        async getFileContent(fileData, path) {
            const file = fileData.zip.file(path);
            if (!file) return null;
            return await file.async('string');
        }

        resolvePathFromOPF(fileData, href) {
            if (href.startsWith('/')) return href.substring(1);
            return fileData.opfDir + '/' + href;
        }

        showInfo(message) {
            this.hideAllStatus();
            const elem = document.getElementById('statusInfo');
            elem.innerHTML = message;
            elem.style.display = 'block';
        }

        showWarning(message) {
            this.hideAllStatus();
            const elem = document.getElementById('statusWarning');
            elem.innerHTML = message;
            elem.style.display = 'block';
        }

        showError(message) {
            this.hideAllStatus();
            const elem = document.getElementById('statusError');
            elem.innerHTML = message;
            elem.style.display = 'block';
        }

        showSuccess(message) {
            this.hideAllStatus();
            const elem = document.getElementById('statusSuccess');
            elem.innerHTML = message;
            elem.style.display = 'block';
        }

        hideAllStatus() {
            document.querySelectorAll('.status').forEach(elem => {
                elem.style.display = 'none';
            });
        }
        
        // New UI methods for multi-file support
        showGlobalError(message) {
            this.showGlobalStatus(message, 'error');
        }
        
        showGlobalWarning(message) {
            this.showGlobalStatus(message, 'warning');
        }
        
        showGlobalStatus(message, type) {
            const container = document.getElementById('globalStatus');
            const alertClasses = {
                info: 'bg-blue-50 border-blue-200 text-blue-800',
                warning: 'bg-yellow-50 border-yellow-200 text-yellow-800',
                error: 'bg-red-50 border-red-200 text-red-800', 
                success: 'bg-green-50 border-green-200 text-green-800'
            };
            
            container.innerHTML = `
                <div class="rounded-lg border p-4 ${alertClasses[type]}">
                    ${message}
                </div>
            `;
            container.style.display = 'block';
        }
        
        updateUI() {
            const container = document.getElementById('fileListContainer');
            container.style.display = this.files.size > 0 ? 'block' : 'none';
            this.updateFileList();
            this.updateBatchButtons();
        }
        
        updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            for (const [filename, fileData] of this.files) {
                const fileItem = this.createFileItem(filename, fileData);
                fileList.appendChild(fileItem);
            }
        }
        
        createFileItem(filename, fileData) {
            const div = document.createElement('div');
            div.className = 'border rounded-lg p-4 bg-card transition-all hover:shadow-sm';
            div.id = `file-${filename.replace(/[^a-zA-Z0-9]/g, '_')}`;
            
            const statusBadge = this.getStatusBadge(fileData.status);
            const issuesInfo = this.getIssuesInfo(fileData);
            
            div.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-3 mb-2">
                            <h3 class="font-medium text-sm truncate" title="${filename}">${filename}</h3>
                            ${statusBadge}
                        </div>
                        ${issuesInfo}
                        ${fileData.error ? `<p class="text-sm text-destructive mt-1">${fileData.error}</p>` : ''}
                    </div>
                    <div class="flex items-center gap-2 ml-4">
                        <button class="analyze-btn inline-flex items-center justify-center rounded-md text-xs font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 ${this.getAnalyzeButtonStyle(fileData)} h-8 px-3" ${fileData.status === 'pending' ? '' : 'disabled'}>
                            Analyze
                        </button>
                        <button class="fix-btn inline-flex items-center justify-center rounded-md text-xs font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 ${this.getFixButtonStyle(fileData)} h-8 px-3" ${fileData.status === 'analyzed' ? '' : 'disabled'}>
                            Fix
                        </button>
                        <button class="download-btn inline-flex items-center justify-center rounded-md text-xs font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 ${this.getDownloadButtonStyle(fileData)} h-8 px-3" ${fileData.status === 'fixed' ? '' : 'disabled'}>
                            Download
                        </button>
                        <button class="remove-btn inline-flex items-center justify-center rounded-md text-xs font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-8 px-2">
                            ×
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            div.querySelector('.analyze-btn').addEventListener('click', () => this.analyzeFile(filename));
            div.querySelector('.fix-btn').addEventListener('click', () => this.fixFile(filename));
            div.querySelector('.download-btn').addEventListener('click', () => this.downloadFile(filename));
            div.querySelector('.remove-btn').addEventListener('click', () => this.removeFile(filename));
            
            return div;
        }
        
        getStatusBadge(status) {
            const badges = {
                pending: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800">Pending</span>',
                analyzing: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800"><div class="w-3 h-3 animate-spin rounded-full border border-blue-600 border-t-transparent mr-1"></div>Analyzing</span>',
                analyzed: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">Analyzed</span>',
                fixing: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-800"><div class="w-3 h-3 animate-spin rounded-full border border-orange-600 border-t-transparent mr-1"></div>Fixing</span>',
                fixed: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">Fixed</span>',
                error: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800">Error</span>'
            };
            return badges[status] || badges.pending;
        }
        
        getIssuesInfo(fileData) {
            if (fileData.status === 'analyzed' && fileData.issues.length > 0) {
                const highCount = fileData.issues.filter(i => i.severity === 'high').length;
                const color = highCount > 0 ? 'text-red-600' : 'text-yellow-600';
                
                const issuesList = fileData.issues.map(issue => `<li class="text-xs text-muted-foreground ml-4">• ${issue.description}</li>`).join('');
                
                return `
                    <details class="text-xs ${color} cursor-pointer">
                        <summary class="hover:text-foreground select-none">${fileData.issues.length} issue${fileData.issues.length !== 1 ? 's' : ''} found</summary>
                        <ul class="mt-1 space-y-1">
                            ${issuesList}
                        </ul>
                    </details>
                `;
            }
            
            if (fileData.status === 'analyzed' && fileData.issues.length === 0) {
                return '<p class="text-xs text-green-600">No issues found</p>';
            }
            
            if (fileData.status === 'fixed' && fileData.fixes.length > 0) {
                const fixesList = fileData.fixes.map(fix => `<li class="text-xs text-muted-foreground ml-4">• ${fix}</li>`).join('');
                
                return `
                    <details class="text-xs text-green-600 cursor-pointer">
                        <summary class="hover:text-foreground select-none">${fileData.fixes.length} fix${fileData.fixes.length !== 1 ? 'es' : ''} applied</summary>
                        <ul class="mt-1 space-y-1">
                            ${fixesList}
                        </ul>
                    </details>
                `;
            }
            
            return '';
        }
        
        getAnalyzeButtonStyle(fileData) {
            // Default style only when it's the next action
            if (fileData.status === 'pending') {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        getFixButtonStyle(fileData) {
            // Default style only when it's the next action
            if (fileData.status === 'analyzed') {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        getDownloadButtonStyle(fileData) {
            // Default style only when it's the next action
            if (fileData.status === 'fixed') {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        // Batch button styling methods
        getBatchAnalyzeStyle() {
            const pendingFiles = Array.from(this.files.values()).filter(f => f.status === 'pending');
            // Primary only if pending files exist and this is the next action in workflow priority
            if (pendingFiles.length > 0) {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        getBatchFixStyle() {
            const pendingFiles = Array.from(this.files.values()).filter(f => f.status === 'pending');
            const analyzedFiles = Array.from(this.files.values()).filter(f => f.status === 'analyzed');
            // Primary only if analyzed files exist AND no pending files (priority: analyze first)
            if (analyzedFiles.length > 0 && pendingFiles.length === 0) {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        getBatchDownloadStyle() {
            const pendingFiles = Array.from(this.files.values()).filter(f => f.status === 'pending');
            const analyzedFiles = Array.from(this.files.values()).filter(f => f.status === 'analyzed');
            const fixedFiles = Array.from(this.files.values()).filter(f => f.status === 'fixed');
            // Primary only if fixed files exist AND no pending/analyzed files (priority: analyze → fix → download)
            if (fixedFiles.length > 0 && pendingFiles.length === 0 && analyzedFiles.length === 0) {
                return 'bg-primary text-primary-foreground hover:bg-primary/90';
            }
            // Outline style otherwise
            return 'border border-input bg-background hover:bg-accent hover:text-accent-foreground';
        }
        
        updateFileItem(filename) {
            const fileData = this.files.get(filename);
            if (!fileData) return;
            
            const existingItem = document.getElementById(`file-${filename.replace(/[^a-zA-Z0-9]/g, '_')}`);
            if (existingItem) {
                const newItem = this.createFileItem(filename, fileData);
                existingItem.replaceWith(newItem);
            }
        }
        
        updateBatchButtons() {
            const analyzeAllBtn = document.getElementById('analyzeAllBtn');
            const fixAllBtn = document.getElementById('fixAllBtn');
            const downloadAllBtn = document.getElementById('downloadAllBtn');
            
            if (!analyzeAllBtn) return; // UI not loaded yet
            
            const pendingFiles = Array.from(this.files.values()).filter(f => f.status === 'pending');
            const analyzedFiles = Array.from(this.files.values()).filter(f => f.status === 'analyzed');
            const fixedFiles = Array.from(this.files.values()).filter(f => f.status === 'fixed');
            
            // Update disabled states
            analyzeAllBtn.disabled = pendingFiles.length === 0;
            fixAllBtn.disabled = analyzedFiles.length === 0;
            downloadAllBtn.disabled = fixedFiles.length === 0;
            
            // Clear existing style classes
            const allStyleClasses = 'bg-primary text-primary-foreground hover:bg-primary/90 border border-input bg-background hover:bg-accent hover:text-accent-foreground'.split(' ');
            
            [analyzeAllBtn, fixAllBtn, downloadAllBtn].forEach(btn => {
                btn.classList.remove(...allStyleClasses);
            });
            
            // Apply new styling
            analyzeAllBtn.classList.add(...this.getBatchAnalyzeStyle().split(' '));
            fixAllBtn.classList.add(...this.getBatchFixStyle().split(' '));
            downloadAllBtn.classList.add(...this.getBatchDownloadStyle().split(' '));
        }
        
        // Batch operations
        async analyzeAllFiles() {
            const pendingFiles = Array.from(this.files.entries()).filter(([_, data]) => data.status === 'pending');
            for (const [filename, _] of pendingFiles) {
                await this.analyzeFile(filename);
            }
        }
        
        async fixAllFiles() {
            const analyzedFiles = Array.from(this.files.entries()).filter(([_, data]) => data.status === 'analyzed');
            for (const [filename, _] of analyzedFiles) {
                await this.fixFile(filename);
            }
        }
        
        async downloadAllFiles() {
            const fixedFiles = Array.from(this.files.entries()).filter(([_, data]) => data.status === 'fixed');
            
            if (fixedFiles.length === 1) {
                await this.downloadFile(fixedFiles[0][0]);
            } else if (fixedFiles.length > 1) {
                // Create ZIP of all fixed files
                const zip = new JSZip();
                
                for (const [filename, fileData] of fixedFiles) {
                    const blob = await fileData.fixedZip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: 9 }
                    });
                    
                    const fixedFilename = filename.replace('.epub', '_fixed.epub');
                    zip.file(fixedFilename, blob);
                }
                
                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fixed_epubs.zip';
                a.click();
                URL.revokeObjectURL(url);
            }
        }
        
        clearAllFiles() {
            this.files.clear();
            document.getElementById('fileInput').value = '';
            this.updateUI();
            document.getElementById('globalStatus').style.display = 'none';
        }
        
        removeFile(filename) {
            this.files.delete(filename);
            this.updateUI();
        }
        
        // Real EPUB fixing implementation
        async fixFile(filename) {
            const fileData = this.files.get(filename);
            if (!fileData || fileData.status !== 'analyzed') return;
            
            fileData.status = 'fixing';
            fileData.fixes = [];
            this.updateFileItem(filename);
            
            try {
                await this.applyFixesToFile(fileData);
                fileData.status = 'fixed';
            } catch (error) {
                fileData.status = 'error';
                fileData.error = 'Fix failed: ' + error.message;
            }
            
            this.updateFileItem(filename);
            this.updateBatchButtons();
        }
        
        async applyFixesToFile(fileData) {
            // Create a new zip for the fixed version
            fileData.fixedZip = new JSZip();
            
            // First pass: copy all files except what we'll modify
            for (let [path, file] of Object.entries(fileData.zip.files)) {
                if (!file.dir) {
                    // Skip files we'll handle specially
                    if (path === fileData.opfPath || path.includes('container.xml')) {
                        continue;
                    }
                    
                    const content = await file.async('uint8array');
                    
                    // Rename OEBPS to EPUB if needed
                    let newPath = path;
                    if (path.includes('OEBPS/')) {
                        newPath = path.replace('OEBPS/', 'EPUB/');
                        if (!fileData.fixes.includes('Changed OEBPS directory to EPUB')) {
                            fileData.fixes.push('Changed OEBPS directory to EPUB');
                        }
                    }
                    
                    // Handle cover image placement based on EPUB version
                    if (fileData.coverImagePath && path.includes(fileData.coverImagePath)) {
                        const filename = path.split('/').pop();
                        
                        // Get EPUB version to determine placement
                        const opfContent = await this.getFileContent(fileData, fileData.opfPath);
                        const parser = new DOMParser();
                        const opfDoc = parser.parseFromString(opfContent, 'text/xml');
                        const epubVersion = opfDoc.documentElement.getAttribute('version');
                        
                        if (epubVersion === '2.0') {
                            // For EPUB 2.0, place cover image at root level as cover.jpeg
                            const epubDir = fileData.opfDir.includes('OEBPS') ? 'EPUB' : fileData.opfDir;
                            newPath = `${epubDir}/cover.jpeg`;
                            fileData.fixes.push('Moved cover image to root level as cover.jpeg for EPUB 2.0');
                        } else {
                            // For EPUB 3.0+, use covers/ subdirectory
                            if (!path.includes('/covers/')) {
                                newPath = newPath.replace(/\/images\//, '/covers/');
                                newPath = newPath.replace(filename, 'cover.jpg');
                                fileData.fixes.push('Moved cover image to covers/cover.jpg');
                            }
                        }
                    }
                    
                    fileData.fixedZip.file(newPath, content);
                }
            }
            
            // Create separate cover.xhtml at EPUB root
            await this.createSeparateCover(fileData);
            
            // Fix OPF file
            await this.fixOPF(fileData);
            
            // Update container.xml
            await this.fixContainer(fileData);
        }
        
        async downloadFile(filename) {
            const fileData = this.files.get(filename);
            if (!fileData || !fileData.fixedZip) return;
            
            const blob = await fileData.fixedZip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 9 }
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.replace('.epub', '_fixed.epub');
            a.click();
            URL.revokeObjectURL(url);
        }
    }

    // Initialize the app when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        new ThemeManager();
        new EPUBCoverFixer();
    });
    </script>
</body>
</html>
